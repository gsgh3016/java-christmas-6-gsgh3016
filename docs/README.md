# 🎄 크리스마스 프로모션

## 📌 프로젝트 개요
이 레포지토리는 우아한 테크 코스 4주차 미션 레포지토리입니다.

## ⚙️ 기능 요구 사항
### 🌟 주요 기능
1. **주문 메뉴 계산**
   - [x] 선택된 메뉴와 수량에 따라 총주문 금액 계산
   - [x] 할인 적용 규칙에 따른 최종 할인 금액 계산

2. **할인 및 증정 계산**
   - [x] 날짜에 따른 크리스마스 디데이 할인 적용
   - [x] 평일 또는 주말에 따른 메뉴별 추가 할인 적용
   - [x] 특별 할인 및 증정 이벤트 적용

3. **이벤트 배지 부여**
   - [x] 총혜택 금액 계산
   - [x] 혜택 금액에 따른 이벤트 배지 결정

### 🛡️ 데이터 검증
1. **날짜 입력 검증**
   - [x] 입력된 날짜가 1 ~ 31 사이인지 확인
   - [x] 유효하지 않은 날짜 입력 시 에러 처리

2. **메뉴 및 수량 검증**
   - [X] 입력된 메뉴가 메뉴판에 있는지 확인
   - [x] 메뉴의 수량이 1 이상인지 확인
   - [x] 중복된 메뉴 입력 여부 확인
   - [x] 주문 가능한 최대 메뉴 수량 (20개) 초과 여부 확인

### 📢 입출력 처리
1. **사용자 입력 처리**
   - [X] 방문 날짜 입력 받기
   - [x] 메뉴 및 수량 입력 받기

2. **결과 출력 처리**
   - [x] 주문 메뉴 및 수량 출력
   - [x] 할인 전 총주문 금액 및 할인 후 예상 결제 금액 출력
   - [x] 증정 메뉴 및 혜택 내역 출력
   - [x] 적용된 이벤트 배지 출력

## 📝 이전 미션 피드백 내용

### 👥 공통 피드백

- 함수는 최대 15라인 이내로 제한하며, 공백 라인도 포함한다.
- 예외 상황 처리를 고려하고, 잘못된 입력에 대한 예외 처리를 포함한다.
- 비즈니스 로직과 UI 로직은 분리해야 한다.
- 객체 상태 확인은 `toString()`으로, View 데이터는 getter로 전달한다.
- 연관 상수는 `enum`으로 관리한다.
- `final` 키워드로 값 변경을 방지한다.
- 인스턴스 변수는 `private`으로 접근을 제한한다.
- 객체는 상태값을 자체 처리하고, 외부와는 메시지로 상호작용한다.
- 필드 수를 최소화하여 객체 복잡도를 줄인다.
- 성공 및 예외 케이스 모두를 포함한 테스트 코드를 작성한다.
- 테스트 코드는 중복 없이 리팩터링한다.
- 테스트 전용 코드는 구현 코드와 분리한다.
- 테스트 어려운 코드는 리팩터링으로 개선한다.
- private 함수 테스트 필요 시 클래스 분리를 고려한다.


### 👤 피어 리뷰

- 필요한 기능에 대해 추가 메소드를 구현할 것을 고려하라.
- 추상 클래스 사용의 명확한 의도를 가지고 적용하라.
- 에러 메시지를 적절한 클래스에서 관리하는 방법을 모색하라.
- 테스트 코드를 간결하게 유지하며, 필요시 메소드 분리를 고려하라.
- 다양한 입력 형식을 받을 수 있는 생성자를 제공하라.
- 하드코딩 대신 상수를 사용하여 코드의 유지보수성을 높이라.
- 전체적인 코드의 깔끔함과 복잡한 로직의 가시성을 유지하라.
- 클래스와 패키지 명이 일치하도록 구조를 검토하라.
- 출력 문구 등을 상수로 관리할 것인지 판단하고 일관성을 유지하라.
- enum 클래스의 역할과 가시성에 주의하고, 에러 메시지를 명확하게 하라.
- equals()와 hashCode() 메소드의 적절한 사용 여부를 검토하라.
- 클래스의 역할과 책임이 명확하도록 구조를 설계하라.
- 객체의 메서드 네이밍을 명확하고 직관적으로 하라.
- 컬렉션 API를 적극 활용하여 코드의 가독성을 높이라.
- enum 상수의 위치와 그 의미를 명확히 하라.
- 비즈니스 로직과 외부 API 간의 결합도를 낮추기 위해 추상화를 고려하라.
- 중복된 코드의 흐름을 개선하기 위해 동작 파라미터화, 함수형 인터페이스, 전략 패턴 등을 활용하라.
- 테스트 코드 작성 시 @ParameterizedTest를 활용하여 효율성을 높이라.

## 🗣️ self-피드백

### 😁 좋았던 점

- 1주차와 비교했을 때 많은 성장을 단기간에 이룩했다.
- 지난 주차부터 이번 주차까지 피어 리뷰를 적극 활용했다.
- 교학상장의 즐거움을 알게됐다.
- 피드백 받은 내용을 대부분 적용했다.
   1. 👥 공통 피드백
   * 비즈니스 로직과 UI 로직의 분리
   * 연관 상수 enum
   * final 적극 활용
   * 객체에서 상태 처리
   * 필드 수 최소화 -> record 활용
   * 테스트 코드 중복 최소화 -> @ParameterizedTest 도입
   * private 함수 테스팅 -> 전체 domain 단위 테스팅으로 해결

   2. 👬 피어 리뷰
   * 에러 메세지 관리 -> record 객체로 관리
   * 복잡한 로직 분리 -> 객체, 메소드의 책임 소재 적절하게 분배
   * 패키지 분리 -> 객체의 역할에 맞춤
   * 출력 문구 상수화
   * enum 클래스 적극 활용
   * 비즈니스 로직, 모델링 로직, 유효성 검사 로직 분리
   * 전략 패턴, 싱글톤, 함수형 인터페이스 활용
- 단기간에 밀도있는 몰입으로 과제를 진행할 수 있었다.

### 😢 아쉬운 점

1. 코드 관련
- 비즈니스 로직에서의 에러 핸들링이 부족하다고 생각했다.
- static 키워드를 잘못 활용해 유효성 검사 로직에서 많이 지체했다.
- monolithic 로직 -> 리팩토링으로 분리 과정이 아닌 처음 설계부터 분리를 너무 신경썼다.

2. 진행 관련
- 문서 -> 테스트 코드 -> 구현 -> 테스팅 과정이 많이 엉켰다. 해당 과정이 아직 미숙하다.
- 피어 리뷰 활동이 적극적이지 않았다. -> 더 많은 피드백을 주고 받고 싶었지만, 일정이 빠듯했다.

### 💡 알게된 점

- 전략 패턴을 사용하는 이유: 서비스 로직을 다양하게 적용하기 위함.
  - 서비스 로직의 캡슐화
  - 객체 의존성 분리
  - 확장성
- 함수형 인터페이스: 기초적으로 람다 함수부터 Predicate, Optional, Stream이 있음
- @ParameterizedTest의 용도
  - 모든 테스트 코드를 파라미터화 하여 진행하면 오버헤드일 수 있음
  - 수많은 테스트 케이스를 캡슐화하여 관리하기 위함.
- enum의 새로운 활용 용도: 상태 관리
  - true, false 두가지 이분법적으로 존재하는 상태가 아닌 다양한 상태를 표현하기 위해서 적절함.
- git의 다양한 활용법
  - 이전에는 reset, revert를 간단하게만 사용
  - 여러 커밋을 변경하기 위해 git rebase -i HEAD~3 커맨드를 활용할 수 있음.
- intellijIDEA 적극 활용: UML 다이어그램을 생성해주는 기능